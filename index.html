<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SHA-256 + AES-256-GCM Live Encryption</title>
<link rel="icon" type="image/png" href="./favicon.png">
<style>
    body { 
		font-family: sans-serif; margin: 1em;
		background-color: #1e1e1e;      /* dark gray background */
		color: #e6e6e6;                /* light gray text */
	}
    textarea, input[type=password], input[type=text] { width: 100%; margin-bottom: 0.25em; 
		background-color: #2b2b2b;     /* darker background for inputs */
		color: #e6e6e6;               /* light gray text */
		border: 1px solid #444;       /* subtle border */
	}
    textarea { height: 40px; }
    button { margin-top: 0.1em; margin-bottom: 0.4em; 
	    background-color: #3a3a3a;     /* dark button background */
		color: #fff;                   /* white button text */
		border: 1px solid #555;        /* subtle border */
		border-radius: 4px;
		padding: 0.3em 0.6em;
		cursor: pointer;
		transition: background-color 0.15s ease;
	}
	button:hover {
		background-color: #4a4a4a;     /* slightly lighter on hover */
	}
	
	h2, h3, h4, h5 { margin: 0.2em 0 0.3em; }
    label { display: block; margin: 0.2em 0; }

    /* Password wrapper styles */
    .password-wrap { position: relative; }
    .password-wrap input[type=password],
    .password-wrap input[type=text] {
        padding-right: 2em;
    }
	
	.count-badge {
		margin-left: .4em;
		padding: 0 .5em;
		border-radius: 1em;
		background: #eee;
		font-size: .85em;
		vertical-align: middle;
		background: #555;              /* darker badge */
		color: #fff;                   /* white text for counter */
	}

    .password-toggle {
        position: absolute;
        right: .4em;
        top: 50%;
        transform: translateY(-50%);
        border: 0;
        background: transparent;
        cursor: pointer;
        width: 1.6em;
        height: 1.6em;
        display: inline-grid;
        place-items: center;
    }
    .password-toggle:focus {
        outline: 2px solid #4a90e2;
        outline-offset: 2px;
    }
    .password-toggle svg {
        width: 1em;
        height: 1em;
		stroke: #ccc;                  /* eye icon light gray */
    }
	.password-toggle:hover svg {
		stroke: #fff;                  /* brighter when hovered */
	}
</style>
</head>
<body>
<h2>SHA-256 + AES-256-GCM Live Encryption</h2>

<label for="textInput">Enter text:</label>
<textarea id="textInput" placeholder="Type text here..."></textarea>
<br>
<button onclick="copyToClipboard('textInput')">Copy Plaintext</button><span class="count-badge">0</span>

<h4>SHA-256 of Input:</h4>
<textarea id="shaOutput" readonly placeholder="SHA-256 will appear here..."></textarea>
<button onclick="copyToClipboard('shaOutput')">Copy SHA-256</button><span class="count-badge">0</span>

<label for="password">Enter password:</label>
<div class="password-wrap">
    <input type="password" id="password" placeholder="Password" style="width:100%; padding:.35em; font-size:1em;">
    <button type="button" id="togglePwd" class="password-toggle" aria-label="Show password" title="Show/Hide">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
            <path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7Z" stroke-width="2"/>
            <circle cx="12" cy="12" r="3" stroke-width="2"/>
        </svg>
    </button>
</div>

<h4>Encrypted Output</h4>
<h4>PBKDF2-100k AES-256-GCM Base64:</h4>
<textarea id="output" placeholder="Encrypted text appears here..."></textarea>
<button onclick="copyToClipboard('output')">Copy Encrypted Text</button><span class="count-badge">0</span>

<h4>Decrypted Text:</h4>
<textarea id="decryptedText" readonly placeholder="Decrypted text appears here..."></textarea>
<button onclick="copyToClipboard('decryptedText')">Copy Decrypted Text</button><span class="count-badge">0</span>

<script>
const textInput = document.getElementById("textInput");
const passwordInput = document.getElementById("password");
const outputBox = document.getElementById("output");
const decryptedBox = document.getElementById("decryptedText");
const shaBox = document.getElementById("shaOutput");

// --- Modern clipboard helper with fallback ---
async function copyToClipboard(elementId) {
    const el = document.getElementById(elementId);
    const text = el.value ?? '';
    try {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
        } else {
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.opacity = '0';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
        }
    } catch {
        console.warn("Clipboard write failed");
    }
}

// Attach counters to any button that is immediately followed by a .count-badge
document.querySelectorAll('button + .count-badge').forEach(span => {
  const btn = span.previousElementSibling;
  if (!btn || btn.id === 'togglePwd') return; // exclude password eye button
  btn.addEventListener('click', () => {
    span.textContent = String((parseInt(span.textContent, 10) || 0) + 1);
  });
});

// --- SHA-256 calculation ---
async function sha256(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// --- Peek password toggle ---
function togglePassword() {
    const pwd = document.getElementById("password");
    const btn = document.getElementById("togglePwd");
    const showing = pwd.type === "text";
    pwd.type = showing ? "password" : "text";
    btn.setAttribute("aria-label", showing ? "Show password" : "Hide password");
}
document.getElementById('togglePwd').addEventListener('click', togglePassword);

// --- Safer Base64 helpers ---
function u8ToBase64(u8) {
    let bin = '';
    for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
    return btoa(bin);
}
function base64ToU8(b64) {
    const bin = atob(b64);
    const u8 = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
    return u8;
}

// AES-256-GCM Encryption
async function encryptText(text, password) {
    if (!text || !password) return "";
    const enc = new TextEncoder();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const keyMaterial = await crypto.subtle.importKey(
        "raw", enc.encode(password), {name: "PBKDF2"}, false, ["deriveKey"]
    );

    const key = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt"]
    );

    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(text));
    const combined = new Uint8Array(salt.byteLength + iv.byteLength + ciphertext.byteLength);
    combined.set(salt, 0);
    combined.set(iv, salt.byteLength);
    combined.set(new Uint8Array(ciphertext), salt.byteLength + iv.byteLength);

    return u8ToBase64(combined);
}

// AES-256-GCM Decryption
async function decryptText(base64, password) {
    if (!base64 || !password) return "";
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    try {
        const combined = base64ToU8(base64);
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const ciphertext = combined.slice(28);

        const keyMaterial = await crypto.subtle.importKey(
            "raw", enc.encode(password), {name: "PBKDF2"}, false, ["deriveKey"]
        );

        const key = await crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["decrypt"]
        );

        const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
        return dec.decode(decrypted);
    } catch (e) {
        return "Decryption failed (wrong password or corrupted data)";
    }
}

// Reactive updates
let updateTimeout;

// Update SHA, encrypt, and decrypt from input text
async function updateFromInput() {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(async () => {
        shaBox.value = await sha256(textInput.value);

        const encrypted = await encryptText(textInput.value, passwordInput.value);
        outputBox.value = encrypted;

        decryptedBox.value = await decryptText(encrypted, passwordInput.value);
    }, 150);
}

// Update decrypted from encrypted text
async function updateFromEncrypted() {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(async () => {
        decryptedBox.value = await decryptText(outputBox.value, passwordInput.value);
    }, 150);
}

// Event listeners
textInput.addEventListener("input", updateFromInput);
passwordInput.addEventListener("input", async () => {
    await updateFromInput();
});
outputBox.addEventListener("input", updateFromEncrypted);
</script>
</body>
</html>
